&>\dev\null：将所有多余报告引入虚空。
2>&1：将标准错误重定向到标准输出，其会和标准输出一起被打印。

\>为覆盖写入，>>为追加写入。

### wc
***-l：*** 只显示行数。

***-c：*** 只显示字节数

***-w：*** 只显示字数。


### find
```find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;```

***-path \<path\>, -ipath \<path\>：*** 路径名称符合\<path\>的文件，ipath为忽略大小写。

***-prune：*** 常跟在-path \<path\>后，用来排除\<path\>目录，为了继续运行后边的内容，需要加-o；如果想排除多个路径，可以用\\(和\\)将多个-path语句包裹起来（中间用-o连接）。

***-name \<name\>, -iname \<name\>：*** 文件名称符合\<name\>的文件，iname为忽略大小写。

***-type \<type\>：*** 文件类型是\<type\>的文件（\<f\>为一般文件，\<d\>为目录）。

***-o或, -a且, -not（!）非：*** 用于连接两个<-表达式>（默认为且）。

***-exec <command命令> {} \\;：*** 将查找出的结果作为参数执行<command命令>，{}表示查找出的内容，\\;为结束符；可以多个-exec语句连用。

### grep

`grep   -expression   pattern 文件或目录`

***-i：*** 不区分大小写。

***-n：*** 显示行号。

***-v：*** 只显示不匹配的行，即取反。

***-E：*** 使用扩展的正则表达式（功能更强大，一个区别是可以用|表示或，连接两个正则表达式）。

***-C <n>：*** 除了显示符合pattern的行之外，还显示该行前后n行。

***-o：*** 只显示匹配pattern的部分（而非行）。

***-l：*** 只显示内容匹配pattern的文件的名称。

***-r：*** 递归匹配，即遇到目录后会匹配其中的文件（grep遇到目录时，需要加-d<动作>，-r相当于-d recurse）。

***--group-separator='string'：*** 如果有多个符合pattern的行，在每行之间加入string作为分隔行。

### sed

`sed -expression   动作 文件`

动作由引号包裹，多个动作间用分号连接；引号末尾字母前加I表示不区分大小写。

***-i：*** in-place，即直接修改源文件。

***-n：*** 仅显示经动作处理后的结果，常与动作p或s连用。

-r：使用扩展正则表达式

***替换s：*** 
```
sed 's/要被取代的字串/新的字串/'      #只替换每行第一个匹配的子串
sed 's/要被取代的字串/新的字串/g'     #替换每行所有匹配的子串
sed '2,4s/要被取代的字串/新的字串/'   #只替换第2至第4行

#以下语句需与-n连用，否则会重复打印被处理的行
sed 's/要被取代的字串/新的字串/p'     #只替换每行第一个匹配的子串
sed 's/要被取代的字串/新的字串/p2'    #只替换每行第二个匹配的子串
sed 's/要被取代的字串/新的字串/gp'    #替换每行所有匹配的子串
sed '2,4s/要被取代的字串/新的字串/p'  #只替换第2至第4行

&表示前面匹配的所有结果
\1表示前面匹配的第一分组
\u（\l）表示将后面的内容首字母变为大（小）写
\U（\L）表示将后面的内容全变为大（小）写

```

***删除d：*** 
```
sed '2,$d'      #删除第2至最后一行
sed '2~4d'      #从第2行开始每隔4行删除一行
sed '2,~4d'     #从第2行开始删除至下一个4的倍数行
sed '2,+4d'     #从第二行开始删除4行
sed '/string/d' #删除含有string的行
sed '/string1\|string2/d' #删除含有string1或string2的行
```
***打印p：*** 用法同删除。

***插入i：*** `sed '2istring'`在第2行前插入一行，内容为string。

***空行G：***
```
sed 'G'          #每行后插入一个空行
sed 'G;G'        #每行后插入两个空行
sed '1G'         #第1行后插入空行
sed '/string/G'  #匹配string的行后插入空行
```

### awk
`awk '{pattern action}' filenames`

所有动作在一对引号内，每个动作用{}包裹。

***-f\<scriptfile\>：*** 读取一个awk脚本。
  
 
 
***-F\<string\>：*** 指定string为源文件字段的分隔符，默认为空格。若有多个分隔符，需要用[]包裹。
 
***-v\<var=value\>：*** 给一个变量赋值。
 
***OFS=string：*** 设定打印分隔符为string。
 
***BEGIN：*** 指定了处理文本前需要执行的操作。放在引号内，{}前。
  
***END：*** 指定了处理文本后需要执行的操作。放在引号内，{}前。

***print：***
 ```
 NF  #每行字段数
 NR  #行号
 $1  #每行第一字段内容
 awk '{print $1}' #打印每行第一字段内容
 ```
